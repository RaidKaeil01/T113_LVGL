记事本数据存储设计说明文档
1. 设计背景

本项目运行于嵌入式 Linux 平台（T113 系列 SoC），系统资源有限，且存在以下典型嵌入式风险场景：

设备可能在写入过程中异常断电

系统文件系统多为 ext4 / UBIFS / YAFFS

用户输入数据（记事本内容）属于关键用户数据

系统无数据库服务或不适合引入复杂依赖

因此，记事本数据存储方案需重点关注：

数据可靠性

掉电安全

实现复杂度

可维护性与可调试性

2. 设计目标

本存储方案的设计目标如下：

保证数据完整性
防止因断电、进程异常退出导致文件内容损坏

实现简单、稳定可靠
避免引入数据库或重量级组件

便于调试和维护
支持通过命令行直接查看和验证数据内容

适配嵌入式系统环境
尽量减少存储写放大与运行时开销

3. 可选方案概述

在方案评估阶段，主要考虑了以下几种实现方式：

方案	描述
方案一	纯文本文件直接读写
方案二	JSON 结构化文件存储
方案三	原子写入 + 备份机制
方案四	二进制数据存储
方案五	多文件 / 笔记索引管理

通过对安全性、复杂度、扩展性和嵌入式适配性的综合评估，最终选择 方案三：原子写入 + 备份机制 作为核心方案。

4. 最终选型方案
4.1 方案描述

采用 纯文本格式 + 原子写入机制 的组合方案：

数据格式：UTF-8 纯文本

主文件：/usr/data/note/notebook.txt

备份文件：/usr/data/note/notebook.txt.bak

临时文件：/usr/data/note/notebook.txt.tmp

该方案通过文件系统原子操作，确保在任意异常情况下数据始终处于一致且可恢复状态。

5. 原子写入方案设计说明
5.1 写入流程

记事本内容写入流程如下：

将新内容写入临时文件 notebook.txt.tmp

调用 fsync() 确保数据真正写入存储介质

将旧主文件重命名为备份文件 notebook.txt.bak

使用 rename() 原子操作将临时文件替换为主文件

必要时对目录执行 fsync()，确保元数据安全

该流程确保写入过程具备事务特性，要么全部成功，要么不影响旧数据。

5.2 读取流程

程序启动或读取记事本内容时：

优先读取主文件 notebook.txt

若主文件不存在或损坏：

自动回退读取备份文件 notebook.txt.bak

确保用户数据在异常情况下仍可恢复

6. 选择原子写入方案的理由
6.1 防止掉电导致的数据损坏

在嵌入式设备中，断电往往不可控。
传统的直接写文件方式在以下情况下容易造成文件截断或内容损坏：

写入过程中突然掉电

系统重启或进程崩溃

文件系统尚未完成数据刷新

原子写入通过 写新文件 + 原子替换 的方式，避免了“半写入”状态。

6.2 利用文件系统原子特性

rename() 在 Linux 文件系统中是原子操作：

不会出现“中间状态”

系统在任何时刻只能看到旧文件或新文件

不依赖额外锁机制

该特性非常适合嵌入式系统中对一致性的要求。

6.3 不引入额外依赖

与 SQLite / JSON 解析库相比：

无需引入第三方库

减少 ROM / RAM 占用

降低系统复杂度与维护成本

适合资源受限的嵌入式设备。

6.4 易于调试和维护

文件内容为纯文本

可直接通过 cat、vi 等命令查看

异常情况下可人工恢复数据

对于现场调试和售后维护非常友好。

7. 与其他方案的对比优势
对比项	原子写入方案
掉电安全	⭐⭐⭐⭐⭐
实现复杂度	⭐⭐⭐
运行时开销	⭐⭐⭐⭐
可维护性	⭐⭐⭐⭐⭐
嵌入式适配性	⭐⭐⭐⭐⭐
8. 扩展性设计说明

虽然当前采用单文件存储，但在接口层面已预留扩展空间：

可在不改变原子写入机制的前提下切换为 JSON

可扩展为多文件或多笔记管理

可结合 SQLite 记录操作日志或历史版本

核心思想是：
数据安全机制优先，数据格式可演进。

9. 结论

本项目最终采用 纯文本格式 + 原子写入 + 备份机制 的存储方案，能够在嵌入式环境中有效平衡：

数据安全性

实现复杂度

系统资源消耗

后期维护成本

该方案在保证可靠性的同时，避免了过度设计，适合当前项目阶段及后续扩展需求。